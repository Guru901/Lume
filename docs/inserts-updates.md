# Inserts and Updates

Lume provides type-safe methods for inserting and updating data in your database.

## Inserts

### Single Insert

Insert a single record:

```rust
db.insert(Users {
    id: None,
    username: "alice".to_string(),
    email: "alice@example.com".to_string(),
    age: 30,
    created_at: 1677721600,
})
.execute()
.await?;
```

### Auto-Increment Primary Keys

When using `auto_increment()`, you can omit the primary key or set it to 0:

```rust
define_schema! {
    Users {
        id: i32 [primary_key().not_null().auto_increment()],
        username: String [not_null()],
    }
}

// Both work:
db.insert(Users {
    id: None,  // or omit entirely
    username: "alice".to_string(),
})
.execute()
.await?;
```

### Default Values

Fields with default values can be omitted or set to `None`:

```rust
define_schema! {
    Users {
        id: i32 [primary_key().not_null()],
        username: String [not_null()],
        is_active: bool [default_value(true)],
    }
}

// is_active will use the default value (true)
db.insert(Users {
    id: 1,
    username: "alice".to_string(),
    is_active: None,  // Uses default
})
.execute()
.await?;
```

### Returning Inserted Rows

Get the inserted row back (PostgreSQL and MySQL):

```rust
let inserted = db.insert(Users {
    id: 1,
    username: "alice".to_string(),
    email: "alice@example.com".to_string(),
    age: 30,
    created_at: 1677721600,
})
.returning(Users::id())
.execute()
.await?;

// inserted contains the inserted row
```

### Bulk Inserts

Insert multiple records at once:

```rust
let users = vec![
    Users {
        id: 1,
        username: "alice".to_string(),
        email: "alice@example.com".to_string(),
        age: 30,
        created_at: 1677721600,
    },
    Users {
        id: 2,
        username: "bob".to_string(),
        email: "bob@example.com".to_string(),
        age: 25,
        created_at: 1677721600,
    },
];

db.insert_many(users)
    .execute()
    .await?;
```

## Updates

### Basic Update

Update records matching a filter:

```rust
use lume::filter::eq_value;

db.update::<Users, UpdateUsers>()
    .set(UpdateUsers {
        age: Some(31),
        email: Some("newemail@example.com".to_string()),
        ..Default::default()
    })
    .filter(eq_value(Users::id(), 1))
    .execute()
    .await?;
```

### Update Struct

The `UpdateUsers` struct is generated by `define_schema!`. All fields are `Option<T>`:

```rust
UpdateUsers {
    username: Option<String>,
    email: Option<String>,
    age: Option<i32>,
    // ...
}
```

Only fields set to `Some(value)` will be updated. Use `Default::default()` for the rest:

```rust
db.update::<Users, UpdateUsers>()
    .set(UpdateUsers {
        age: Some(31),
        ..Default::default()  // All other fields unchanged
    })
    .filter(eq_value(Users::id(), 1))
    .execute()
    .await?;
```

### Updating Multiple Fields

Set multiple fields at once:

```rust
db.update::<Users, UpdateUsers>()
    .set(UpdateUsers {
        username: Some("alice_new".to_string()),
        email: Some("newemail@example.com".to_string()),
        age: Some(31),
        ..Default::default()
    })
    .filter(eq_value(Users::id(), 1))
    .execute()
    .await?;
```

### Complex Update Filters

Use complex filters for updates:

```rust
use lume::filter::{and, eq_value, gt};

db.update::<Users, UpdateUsers>()
    .set(UpdateUsers {
        status: Some("active".to_string()),
        ..Default::default()
    })
    .filter(
        and(
            eq_value(Users::status(), "pending"),
            gt(Users::age(), 18)
        )
    )
    .execute()
    .await?;
```

### Updating All Rows

Update all rows (use with caution):

```rust
db.update::<Users, UpdateUsers>()
    .set(UpdateUsers {
        status: Some("active".to_string()),
        ..Default::default()
    })
    .execute()
    .await?;
```

## Deletes

### Delete with Filter

Delete records matching a filter:

```rust
use lume::filter::eq_value;

db.delete::<Users>()
    .filter(eq_value(Users::id(), 1))
    .execute()
    .await?;
```

### Delete All

Delete all records (use with caution):

```rust
db.delete::<Users>()
    .execute()
    .await?;
```

### Complex Delete Filters

Use complex filters for deletes:

```rust
use lume::filter::{and, eq_value, lt};

db.delete::<Users>()
    .filter(
        and(
            eq_value(Users::status(), "inactive"),
            lt(Users::created_at(), 1609459200)  // Older than date
        )
    )
    .execute()
    .await?;
```

## Error Handling

All operations return `Result` types:

```rust
match db.insert(Users { /* ... */ })
    .execute()
    .await
{
    Ok(_) => println!("Insert successful"),
    Err(e) => eprintln!("Insert failed: {}", e),
}
```

## Type Safety

All insert and update operations are type-checked at compile time:

```rust
// ✅ Works - correct types
db.insert(Users {
    id: 1,
    username: "alice".to_string(),
    age: 30,
    // ...
})
.execute()
.await?;

// ❌ Compile error - wrong types
// db.insert(Users {
//     id: "wrong",  // Error!
//     username: 123,  // Error!
//     // ...
// })
```

## Best Practices

1. **Use transactions** - Wrap multiple operations in transactions when needed
2. **Validate data** - Validate data before inserting/updating
3. **Use filters carefully** - Always use filters for updates and deletes unless you really want to affect all rows
4. **Handle errors** - Always handle `Result` types from database operations
5. **Use bulk inserts** - Use `insert_many()` for multiple records instead of multiple `insert()` calls

## Next Steps

- Learn about [Queries](queries.md) for reading data
- Check out [Filters](filters.md) for update/delete conditions
- See [Advanced Topics](advanced.md) for transactions and more
